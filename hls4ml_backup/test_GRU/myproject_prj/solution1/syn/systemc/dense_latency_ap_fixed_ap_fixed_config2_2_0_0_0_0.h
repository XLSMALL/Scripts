// ==============================================================
// RTL generated by Vivado(TM) HLS - High-Level Synthesis from C, C++ and OpenCL
// Version: 2019.2
// Copyright (C) 1986-2019 Xilinx, Inc. All Rights Reserved.
// 
// ===========================================================

#ifndef _dense_latency_ap_fixed_ap_fixed_config2_2_0_0_0_0_HH_
#define _dense_latency_ap_fixed_ap_fixed_config2_2_0_0_0_0_HH_

#include "systemc.h"
#include "AESL_pkg.h"

#include "myproject_mul_16s_11ns_26_2_0.h"
#include "myproject_mul_16s_9ns_25_2_0.h"

namespace ap_rtl {

struct dense_latency_ap_fixed_ap_fixed_config2_2_0_0_0_0 : public sc_module {
    // Port declarations 7
    sc_in_clk ap_clk;
    sc_in< sc_logic > ap_rst;
    sc_in< sc_lv<16> > data_V_read;
    sc_out< sc_lv<16> > ap_return_0;
    sc_out< sc_lv<16> > ap_return_1;
    sc_out< sc_lv<16> > ap_return_2;
    sc_in< sc_logic > ap_ce;


    // Module declarations
    dense_latency_ap_fixed_ap_fixed_config2_2_0_0_0_0(sc_module_name name);
    SC_HAS_PROCESS(dense_latency_ap_fixed_ap_fixed_config2_2_0_0_0_0);

    ~dense_latency_ap_fixed_ap_fixed_config2_2_0_0_0_0();

    sc_trace_file* mVcdFile;

    myproject_mul_16s_11ns_26_2_0<1,2,16,11,26>* myproject_mul_16s_11ns_26_2_0_U48;
    myproject_mul_16s_9ns_25_2_0<1,2,16,9,25>* myproject_mul_16s_9ns_25_2_0_U49;
    sc_signal< bool > ap_block_state1_pp0_stage0_iter0;
    sc_signal< bool > ap_block_state2_pp0_stage0_iter1;
    sc_signal< bool > ap_block_pp0_stage0_11001;
    sc_signal< sc_lv<14> > trunc_ln708_2_reg_193;
    sc_signal< sc_lv<11> > grp_fu_54_p1;
    sc_signal< bool > ap_block_pp0_stage0;
    sc_signal< sc_lv<9> > grp_fu_56_p1;
    sc_signal< sc_lv<16> > sext_ln1118_2_fu_101_p0;
    sc_signal< sc_lv<16> > tmp_fu_110_p1;
    sc_signal< sc_lv<23> > tmp_fu_110_p3;
    sc_signal< sc_lv<24> > sext_ln1118_2_fu_101_p1;
    sc_signal< sc_lv<24> > sext_ln1118_4_fu_118_p1;
    sc_signal< sc_lv<24> > sub_ln1118_fu_122_p2;
    sc_signal< sc_lv<25> > grp_fu_56_p2;
    sc_signal< sc_lv<15> > trunc_ln_fu_138_p4;
    sc_signal< sc_lv<26> > grp_fu_54_p2;
    sc_signal< sc_lv<16> > sext_ln708_fu_148_p1;
    sc_signal< sc_lv<16> > acc_1_V_fu_152_p1;
    sc_signal< sc_logic > grp_fu_54_ce;
    sc_signal< sc_logic > grp_fu_56_ce;
    sc_signal< sc_logic > ap_ce_reg;
    sc_signal< sc_lv<16> > ap_return_0_int_reg;
    sc_signal< sc_lv<16> > ap_return_1_int_reg;
    sc_signal< sc_lv<16> > ap_return_2_int_reg;
    static const sc_logic ap_const_logic_1;
    static const sc_logic ap_const_logic_0;
    static const bool ap_const_boolean_1;
    static const bool ap_const_boolean_0;
    static const sc_lv<26> ap_const_lv26_3DF;
    static const sc_lv<25> ap_const_lv25_DF;
    static const sc_lv<7> ap_const_lv7_0;
    static const sc_lv<32> ap_const_lv32_A;
    static const sc_lv<32> ap_const_lv32_17;
    static const sc_lv<32> ap_const_lv32_18;
    static const sc_lv<32> ap_const_lv32_19;
    // Thread declarations
    void thread_ap_clk_no_reset_();
    void thread_acc_1_V_fu_152_p1();
    void thread_ap_block_pp0_stage0();
    void thread_ap_block_pp0_stage0_11001();
    void thread_ap_block_state1_pp0_stage0_iter0();
    void thread_ap_block_state2_pp0_stage0_iter1();
    void thread_ap_return_0();
    void thread_ap_return_1();
    void thread_ap_return_2();
    void thread_grp_fu_54_ce();
    void thread_grp_fu_54_p1();
    void thread_grp_fu_56_ce();
    void thread_grp_fu_56_p1();
    void thread_sext_ln1118_2_fu_101_p0();
    void thread_sext_ln1118_2_fu_101_p1();
    void thread_sext_ln1118_4_fu_118_p1();
    void thread_sext_ln708_fu_148_p1();
    void thread_sub_ln1118_fu_122_p2();
    void thread_tmp_fu_110_p1();
    void thread_tmp_fu_110_p3();
    void thread_trunc_ln_fu_138_p4();
};

}

using namespace ap_rtl;

#endif
